[TOC]
## Shell
/etc/shells记录系统所有shell
## bash shell 功能
### 命令编修能力  

> 默认指令记忆功能可以达到1000个
> 记录位置~/.bash_history(当前指令用户指令在内存中,登出后才记录到文件此内)

- 命令与文件实例功能(tab补全)
- 命令别名设置功能
- 工作控制/前景背景控制
- 程序化脚本shell script
- 万用字符(*)

### type指令
type 这个指令我们可以知道每个指令是否为 bash 的内置指令。 此外，type只能查找可执行文件.

```
[dmtsai@study ~]$ type [-tpa] name
选项与参数：
    ：不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令
-t  ：当加入 -t 参数时，type 会将 name 以下面这些字眼显示出他的意义：
      file    ：表示为外部指令；
      alias   ：表示该指令为命令别名所设置的名称；
      builtin ：表示该指令为 bash 内置的指令功能；
-p  ：如果后面接的 name 为外部指令时，才会显示完整文件名；
-a  ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias
```

### 快速编辑
- 反斜杠( \\ )
命令输入太长需要换行,利用反斜杠( \\ )[Enter]开启下一行,而不执行命令.  
**注意: [Enter] 按键是紧接着反斜线 （ \\ ）**

- 快捷键

<table>
	<tr>
		<th>组合键</th>
		<th>功能与示范</th>
	</tr>
	<tr>
		<td>[ctrl]+u/[ctrl]+k</td>
		<td>分别是从光标处向前删除指令串 （[ctrl]+u） 及向后删除指令串 （[ctrl]+k） </td>
	</tr>
	<tr>
		<td>[ctrl]+a/[ctrl]+e</td>
		<td>分别是让光标移动到整个指令串的最前面 （[ctrl]+a） 或最后面 （[ctrl]+e） </td>
	</tr>
</table>

### 变量
- echo 指令
显示变量内容,"-e"选项可以格式化打印内容

```
[dmtsai@study ~]$ echo $PATH
```

- 变量设置规则
	1. 变量与变量内容以一个"="来连接.  
		`myname=Windus`
	2. 等号两边不能直接接空白符.
	
		```
		#错误
		myname= Windus
		myname=Windus L
		```
	
	3. 变量内容若有空白符可使用双引号或单引号将变量内容结合起来.  
	
		```
		#双引号内特殊字符可保持原本特性,如:"$"等
		var="lang is $LANG"
		echo $var --> lang is UTF8
		
		#单引号内的特殊字符仅为一般字符(纯文本)
		var='lang is $LANG'
		echo $var --> lang is $LANG
		```  
	
	4. 变量名称只能是英文字母与数字,但开头字符不能是数字.
	5. 可用跳脱字符" \\ ",将特殊符号变成一般符号。(如： [Enter], $, \, 空白字符等）  
		`myname=Windus\ L`
	6. 在一串指令的执行中，还需要借由其他额外的指令所提供的信息时，可以使用反单引号“`指令`”或 “$（指令） 
		
		```
		version=$（uname -r）
		echo $version --> 3.10.0-229.el7.x86_64
		```
		
	7. 若该变量为扩增变量内容时，则可用 "\$变量名称" 或 ${变量} 累加内容
		
		```
		PATH="$PATH":/home/bin
		或
		PATH=${PATH}:/home/bin
		```
		
	8. 若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量
		`export PATH`
		
	9. 通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断 （纯粹依照使用者兴趣与嗜好,在 Linux 默认的情况中，使用{大写的字母}来设置的变量一般为系统内定需要的变量）
	10. 取消变量用unset
		`unset myname`

#### 环境变量
- env命令  
	查看所有环境变量
	- HOME 使用者主文件夹变量, ~就会读取此变量
	- SHELL 目前环境使用的SHELL程序(Linux默认:/bin/bash)
	- HISTSIZE 历史命令记录笔数
	- MAIL 当前用户邮箱文件
	- PATH 可执行文件搜寻的路径(目录与目录中间:分隔).由于搜寻顺序依据PATH变量内目录顺序,所以目录顺序也是重要的.
	- LANG 语系数据
	- RANDOM 随机数变量(/dev/random),内容介于0~32767之间.
		
		```
		#想要获取指定范围内的数,使用delcare声名数值类型
		[dmtsai@study ~]$ declare -i number=$RANDOM*10/32768 ; 
		echo $number
		8   <== 此时会随机取出 0~9 之间的数值喔！
		```
- set命令
	查看所有变量(含环境变量与自定变量)
	- PS1 提示字符的设置
		
		```
		\d ：可显示出“星期 月 日”的日期格式，如："Mon Feb 2"
		\H ：完整的主机名称。举例来说，鸟哥的练习机为“study.centos.vbird”
		\h ：仅取主机名称在第一个小数点之前的名字，如鸟哥主机则为“study”后面省略
		\t ：显示时间，为 24 小时格式的“HH:MM:SS”
		\T ：显示时间，为 12 小时格式的“HH:MM:SS”
		\A ：显示时间，为 24 小时格式的“HH:MM”
		\@ ：显示时间，为 12 小时格式的“am/pm”样式
		\u ：目前使用者的帐号名称，如“dmtsai”；
		\v ：BASH 的版本信息，如鸟哥的测试主机版本为 4.2.46（1）-release，仅取“4.2”显示
		\w ：完整的工作目录名称，由根目录写起的目录名称。但主文件夹会以 ~ 取代；
		\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。
		\# ：下达的第几个指令。
		\$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 
		```
		
	- \$ 本shell的PID  
		`echo $$`
	- ? 上个指令的回传值
		执行某些指令时， 这些指令都会回传一个执行后的代码。一般来说，如果成功的执行该指令， 则会回传一个 0 值,如果执行过程发生错误,就会传回错误代码.一般以非0代码取代.
		
- export命令  
	当你登陆 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，这个程序的识别使用的是一个称为程序识别码，被称为 PID 的就是。 接下来你在这个 bash 下面所下达的任何指令都是由这个 bash 所衍生出来的，那些被下达的指令就被称为子程序了.
	![程序相关性示意图](img/QQ20180307-115110@2x.png)

	子程序仅会继承父程序的环境变量， 子程序不会继承父程序的自订变量.所以你在原本 bash 的自订变量在进入了子程序后就会消失不见， 一直到你离开子程序并回到原本的父程序后，这个变量才会又出现！
此时,把自定变量变成环境变量就变得很有必要了:
`export 变量名称`

如果export后面不加变量名称,就会将系统所有变量列出来,等同于set命令.

#### 语系变量
- 查看Linux支持的语系
	
	```
	[dmtsai@study ~]$ locale -a
	....（前面省略）....
	zh_TW
	zh_TW.big5     <==大五码的中文编码
	zh_TW.euctw
	zh_TW.utf8     <==万国码的中文编码
	zu_ZA
	zu_ZA.iso88591
	zu_ZA.utf8
	```
	
- 修改Linux语系

	```
	locale  <==后面不加任何选项与参数即可！
	LANG=en_US                   <==主语言的环境
	LC_CTYPE="en_US"             <==字符（文字）辨识的编码
	LC_NUMERIC="en_US"           <==数字系统的显示讯息
	LC_TIME="en_US"              <==时间系统的显示数据
	LC_COLLATE="en_US"           <==字串的比较与排序等
	LC_MONETARY="en_US"          <==币值格式的显示等
	LC_MESSAGES="en_US"          <==讯息显示的内容，如功能表、错误讯息等
	LC_ALL=                      <==整体语系的环境
	....（后面省略）....
	```
	
	可以逐一设置每个与语系有关的变量数据,可也以直接设置LANG或LC_ALL(其它语系变量会被这两个变量所取代).
	
	系统默认语系文件是: **/etc/locale.conf**

#### 变量范围
环境变量可以被子程序引用的原理:
1. 当启动一个shell,系统会分配一个记忆区给shell使用,使此内存内的变量,即环境变量可让子程序使用.
2. 若父程序用export功能,将自定变量内容写到上述内存区块当中(环境变量).
3. 当载入另一个shell时(亦启动一个子程序,离开原本父程序),子程序可以将父shell的环境变量所在记忆区导入自己的环境变量区块当中.

#### 变量键盘读取/阵列与宣告
- read命令
	程序执行的过程当中，会等待使用者输入 "yes/no" 之类的讯息,和使用者对谈时使用此命令.

	```
	[dmtsai@study ~]$ read [-pt] variable
	选项与参数：
	-p  ：后面可以接提示字符！
	-t  ：后面可以接等待的“秒数！”这个比较有趣～不会一直等待使用者啦！
	```

- declare/typeset
	declare 或 typeset 是一样的功能，就是在“宣告变量的类型.
	
	```
	[dmtsai@study ~]$ declare [-aixr] variable
	选项与参数：
	-a  ：将后面名为 variable 的变量定义成为阵列 （array） 类型
	-i  ：将后面名为 variable 的变量定义成为整数数字 （integer） 类型
	-x  ：用法与 export 一样，就是将后面的 variable 变成环境变量；
	-r  ：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset
	-p	 : 仅列出变量类型
	
	范例一：让变量 sum 进行 100+300+50 的加总结果
	[dmtsai@study ~]$ sum=100+300+50
	[dmtsai@study ~]$ echo ${sum}
	100+300+50  <==咦！怎么没有帮我计算加总？因为这是文字体态的变量属性啊！
	[dmtsai@study ~]$ declare -i sum=100+300+50
	[dmtsai@study ~]$ echo ${sum}
	450         <==瞭乎？？
	```
	
	> 注意 : bash环境下,变量类型默认为“字串”，所以若不指定变量类型，则 1+2 为一个“字串”而不是“计算式”。 所以上述第一个执行的结果才会出现那个情况的；
bash 环境中的数值运算，默认最多仅能到达整数形态，所以 1/3 结果是 0； 

#### 变量内容删除/取代/替换
***
暂时跳过
***
	
### 系统限制关系 ulimit  

```
[dmtsai@study ~]$ ulimit [-SHacdfltu] [配额]
选项与参数：
-H  ：hard limit ，严格的设置，必定不能超过这个设置的数值；
-S  ：soft limit ，警告的设置，可以超过这个设置值，但是若超过则有警告讯息。
      在设置上，通常 soft 会比 hard 小，举例来说，soft 可设置为 80 而 hard 
      设置为 100，那么你可以使用到 90 （因为没有超过 100），但介于 80~100 之间时，
      系统会有警告讯息通知你！
-a  ：后面不接任何选项与参数，可列出所有的限制额度；
-c  ：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件（除错用），
      这种文件就被称为核心文件（core file）。此为限制每个核心文件的最大容量。
-f  ：此 shell 可以创建的最大文件大小（一般可能设置为 2GB）单位为 KBytes
-d  ：程序可使用的最大断裂内存（segment）容量；
-l  ：可用于锁定 （lock） 的内存量
-t  ：可使用的最大 CPU 时间 （单位为秒）
-u  ：单一使用者可以使用的最大程序（process）数量。
```

### 命令别名与历史命令

